<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Тетрис</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    body {
      background-color: #f0f0f0;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      min-height: 100vh;
      overflow: hidden;
    }

    header {
      margin-bottom: 10px;
      text-align: center;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 5px;
    }

    /* Рекорды сверху с прокруткой */
    .records-container {
      width: 100%;
      max-width: 300px;
      margin-bottom: 10px;
      background-color: #fff;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .records-header {
      background-color: #4a4a4a;
      color: white;
      padding: 8px;
      text-align: center;
      font-weight: bold;
      font-size: 14px;
    }

    .records-scroll {
      display: flex;
      overflow-x: auto;
      padding: 10px;
      gap: 10px;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: #4a4a4a #f1f1f1;
    }

    .records-scroll::-webkit-scrollbar {
      height: 6px;
    }

    .records-scroll::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }

    .records-scroll::-webkit-scrollbar-thumb {
      background: #4a4a4a;
      border-radius: 3px;
    }

    .record-item {
      flex: 0 0 auto;
      background-color: #f5f5f5;
      border-radius: 5px;
      padding: 10px;
      min-width: 120px;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .record-score {
      font-size: 18px;
      font-weight: bold;
      color: #4a4a4a;
      margin-bottom: 5px;
    }

    .record-date {
      font-size: 12px;
      color: #777;
    }

    .score-info {
      display: flex;
      justify-content: space-around;
      width: 100%;
      max-width: 300px;
      margin-bottom: 10px;
    }

    .score-item {
      text-align: center;
    }

    .score-value {
      font-size: 18px;
      font-weight: bold;
    }

    .game-container {
      position: relative;
      margin-bottom: 10px;
    }

    #tetris {
      display: block;
      background-color: #fff;
      border: 2px solid #333;
    }

    .mobile-controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      width: 100%;
      max-width: 300px;
    }

    .control-btn {
      background-color: #4a4a4a;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:active {
      background-color: #333;
    }

    #rotateBtn {
      grid-column: 2;
      grid-row: 1;
    }

    #leftBtn {
      grid-column: 1;
      grid-row: 2;
    }

    #downBtn {
      grid-column: 2;
      grid-row: 2;
    }

    #rightBtn {
      grid-column: 3;
      grid-row: 2;
    }

    #dropBtn {
      grid-column: 1 / 4;
      grid-row: 3;
    }

    .start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #4a4a4a;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 15px 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
    }

    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 5px;
      text-align: center;
      display: none;
      z-index: 10;
    }

    .game-over h2 {
      margin-bottom: 10px;
    }

    .game-over button {
      background-color: #4a4a4a;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 10px 20px;
      margin-top: 10px;
      cursor: pointer;
    }

    @media (min-width: 768px) {
      .mobile-controls {
        display: none;
      }

      #tetris {
        width: 300px;
        height: 600px;
      }
    }

    @media (max-width: 767px) {
      #tetris {
        width: 100%;
        max-width: 300px;
        height: auto;
        aspect-ratio: 1/2;
      }

      body {
        padding-bottom: 240px;
      }

      .records-container {
        max-width: 100%;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>ТЕТРИС</h1>
  </header>

  <!-- Рекорды сверху с прокруткой -->
  <div class="records-container">
    <div class="records-header">ТОП РЕКОРДОВ</div>
    <div class="records-scroll" id="recordsList">
      <div class="record-item">
        <div class="record-score">0</div>
        <div class="record-date">Загрузка...</div>
      </div>
    </div>
  </div>

  <div class="score-info">
    <div class="score-item">
      <div class="score-value" id="score">0</div>
      <div>ОЧКИ</div>
    </div>
    <div class="score-item">
      <div class="score-value" id="pieces">0</div>
      <div>ФИГУР</div>
    </div>
  </div>

  <div class="game-container">
    <canvas id="tetris"></canvas>
    <button class="start-btn" id="startBtn">НАЧАТЬ ИГРУ</button>
    <div class="game-over" id="gameOver">
      <h2>ИГРА ОКОНЧЕНА!</h2>
      <p id="finalScore"></p>
      <button id="restartBtn">ИГРАТЬ СНОВА</button>
    </div>
  </div>

  <div class="mobile-controls">
    <button class="control-btn" id="rotateBtn">↻</button>
    <button class="control-btn" id="leftBtn">←</button>
    <button class="control-btn" id="downBtn">↓</button>
    <button class="control-btn" id="rightBtn">→</button>
    <button class="control-btn" id="dropBtn">СБРОСИТЬ</button>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const piecesElement = document.getElementById('pieces');
    const startBtn = document.getElementById('startBtn');
    const gameOverDiv = document.getElementById('gameOver');
    const finalScoreElement = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');
    const recordsList = document.getElementById('recordsList');

    // Установка размеров canvas
    function setCanvasSize() {
      if (window.innerWidth <= 767) {
        canvas.width = 300;
        canvas.height = 600;
      } else {
        canvas.width = 300;
        canvas.height = 600;
      }
    }

    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = canvas.width / COLS;

    let board = [];
    let currentPiece = null;
    let score = 0;
    let pieces = 0;
    let gameRunning = false;
    let gameInterval = null;
    let records = [];

    // Фигуры тетриса
    const PIECES = [
      [[1, 1, 1, 1]], // I
      [[1, 1], [1, 1]], // O
      [[0, 1, 0], [1, 1, 1]], // T
      [[0, 1, 1], [1, 1, 0]], // S
      [[1, 1, 0], [0, 1, 1]], // Z
      [[1, 0, 0], [1, 1, 1]], // J
      [[0, 0, 1], [1, 1, 1]]  // L
    ];

    // Цвета фигур
    const COLORS = [
      '#00f0f0', // I - голубой
      '#f0f000', // O - желтый
      '#a000f0', // T - фиолетовый
      '#00f000', // S - зеленый
      '#f00000', // Z - красный
      '#0000f0', // J - синий
      '#f0a000'  // L - оранжевый
    ];

    // Инициализация игрового поля
    function initBoard() {
      board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    }

    // Создание новой фигуры
    function createPiece() {
      const typeId = Math.floor(Math.random() * PIECES.length);
      return {
        shape: PIECES[typeId],
        color: COLORS[typeId],
        x: Math.floor(COLS / 2) - Math.floor(PIECES[typeId][0].length / 2),
        y: 0
      };
    }

    // Отрисовка блока
    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // Отрисовка игрового поля
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Отрисовка существующих блоков
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) {
            drawBlock(x, y, board[y][x]);
          }
        }
      }

      // Отрисовка текущей фигуры
      if (currentPiece) {
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              drawBlock(
                currentPiece.x + x,
                currentPiece.y + y,
                currentPiece.color
              );
            }
          }
        }
      }
    }

    // Проверка столкновений
    function checkCollision(piece, offsetX = 0, offsetY = 0) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const newX = piece.x + x + offsetX;
            const newY = piece.y + y + offsetY;

            if (
              newX < 0 ||
              newX >= COLS ||
              newY >= ROWS ||
              (newY >= 0 && board[newY][newX])
            ) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Фиксация фигуры на поле
    function lockPiece() {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            const boardY = currentPiece.y + y;
            const boardX = currentPiece.x + x;
            if (boardY >= 0) {
              board[boardY][boardX] = currentPiece.color;
            }
          }
        }
      }

      pieces++;
      piecesElement.textContent = pieces;
      checkLines();
      currentPiece = createPiece();

      if (checkCollision(currentPiece)) {
        endGame();
      }
    }

    // Проверка и удаление заполненных линий
    function checkLines() {
      let linesCleared = 0;

      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          y++;
        }
      }

      if (linesCleared > 0) {
        const points = [40, 100, 300, 1200];
        score += points[linesCleared - 1] || 0;
        scoreElement.textContent = score;
      }
    }

    // Движение фигуры
    function movePiece(direction) {
      if (!currentPiece || !gameRunning) return;

      let offsetX = 0;
      let offsetY = 0;

      switch (direction) {
        case 'left':
          offsetX = -1;
          break;
        case 'right':
          offsetX = 1;
          break;
        case 'down':
          offsetY = 1;
          break;
      }

      if (!checkCollision(currentPiece, offsetX, offsetY)) {
        currentPiece.x += offsetX;
        currentPiece.y += offsetY;
        drawBoard();
      } else if (direction === 'down') {
        lockPiece();
      }
    }

    // Поворот фигуры
    function rotatePiece() {
      if (!currentPiece || !gameRunning) return;

      const rotated = [];
      for (let i = 0; i < currentPiece.shape[0].length; i++) {
        const row = [];
        for (let j = currentPiece.shape.length - 1; j >= 0; j--) {
          row.push(currentPiece.shape[j][i]);
        }
        rotated.push(row);
      }

      const originalShape = currentPiece.shape;
      currentPiece.shape = rotated;

      if (checkCollision(currentPiece)) {
        currentPiece.shape = originalShape;
      } else {
        drawBoard();
      }
    }

    // Мгновенное падение
    function hardDrop() {
      if (!currentPiece || !gameRunning) return;

      while (!checkCollision(currentPiece, 0, 1)) {
        currentPiece.y++;
      }
      lockPiece();
      drawBoard();
    }

    // Загрузка рекордов с сервера
    async function loadRecords() {
      try {
        const response = await fetch('https://terrisbrev.loca.lt/api/tetris/list', {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'X-App-Agent': 'TetrisWebClient/1.0',
            'bypass-tunnel-reminder': '1'
          }
        });

        if (!response.ok) {
          throw new Error('Ошибка загрузки рекордов');
        }

        records = await response.json();
        updateRecordsDisplay();
      } catch (error) {
        console.error('Ошибка при загрузке рекордов:', error);
        // Если не удалось загрузить, показываем сообщение об ошибке
        recordsList.innerHTML = `
          <div class="record-item">
            <div class="record-score">0</div>
            <div class="record-date">Ошибка загрузки</div>
          </div>
        `;
      }
    }

    // Отправка рекорда на сервер
    async function sendRecord() {
      if (score === 0) return; // Не отправляем нулевые рекорды

      try {
        const response = await fetch('https://terrisbrev.loca.lt/api/tetris/win', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-App-Agent': 'TetrisWebClient/1.0',
            'bypass-tunnel-reminder': '1'
          },
          body: JSON.stringify({
            score: score,
            pieces: pieces
          })
        });

        if (!response.ok) {
          throw new Error('Ошибка отправки рекорда');
        }

        const result = await response.json();
        console.log('Рекорд успешно отправлен:', result);

        // После успешной отправки обновляем список рекордов
        await loadRecords();
      } catch (error) {
        console.error('Ошибка при отправке рекорда:', error);
      }
    }

    // Обновление отображения рекордов
    function updateRecordsDisplay() {
      recordsList.innerHTML = '';

      if (records.length === 0) {
        recordsList.innerHTML = `
          <div class="record-item">
            <div class="record-score">0</div>
            <div class="record-date">Нет рекордов</div>
          </div>
        `;
        return;
      }

      // Сортируем рекорды по убыванию очков
      records.sort((a, b) => b.score - a.score);

      // Отображаем топ-10 рекордов
      const topRecords = records.slice(0, 10);

      topRecords.forEach(record => {
        const recordElement = document.createElement('div');
        recordElement.className = 'record-item';

        // Преобразуем timestamp в дату
        const date = new Date(record.ts);
        const dateString = date.toLocaleDateString();

        recordElement.innerHTML = `
          <div class="record-score">${record.score}</div>
          <div class="record-date">${dateString}</div>
        `;
        recordsList.appendChild(recordElement);
      });
    }

    // Начало игры
    function startGame() {
      initBoard();
      currentPiece = createPiece();
      score = 0;
      pieces = 0;
      gameRunning = true;

      scoreElement.textContent = score;
      piecesElement.textContent = pieces;
      startBtn.style.display = 'none';
      gameOverDiv.style.display = 'none';

      gameInterval = setInterval(gameLoop, 500);
      drawBoard();
    }

    // Игровой цикл
    function gameLoop() {
      if (!gameRunning) return;
      movePiece('down');
    }

    // Окончание игры
    function endGame() {
      gameRunning = false;
      clearInterval(gameInterval);

      finalScoreElement.textContent = `Счёт: ${score} очков (${pieces} фигур)`;
      gameOverDiv.style.display = 'block';

      // Отправляем рекорд на сервер
      sendRecord();
    }

    // Обработчики событий для мобильных кнопок
    document.getElementById('leftBtn').addEventListener('click', () => movePiece('left'));
    document.getElementById('rightBtn').addEventListener('click', () => movePiece('right'));
    document.getElementById('downBtn').addEventListener('click', () => movePiece('down'));
    document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
    document.getElementById('dropBtn').addEventListener('click', hardDrop);

    // Обработчики событий для клавиатуры
    document.addEventListener('keydown', (e) => {
      if (!gameRunning) return;

      switch (e.key) {
        case 'ArrowLeft':
          movePiece('left');
          break;
        case 'ArrowRight':
          movePiece('right');
          break;
        case 'ArrowDown':
          movePiece('down');
          break;
        case 'ArrowUp':
          rotatePiece();
          break;
        case ' ':
          e.preventDefault();
          hardDrop();
          break;
      }
    });

    // Обработчики кнопок старта и перезапуска
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

    // Инициализация
    initBoard();
    drawBoard();
    loadRecords();
  </script>
</body>

</html>
